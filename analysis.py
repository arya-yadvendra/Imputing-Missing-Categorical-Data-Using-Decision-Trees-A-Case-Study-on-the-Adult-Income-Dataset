# -*- coding: utf-8 -*-
"""Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oHzXDqsm5_qo6At1wKMoYb2DadyUBLPy
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

from sklearn import tree

column_names = ['age', 'workclass', 'fnlwgt', 'education', 'educational-num','marital-status', 'occupation', 'relationship', 'race', 'gender','capital-gain', 'capital-loss', 'hours-per-week', 'native-country','income']

train = pd.read_csv('adult_data (1).txt', sep=",\s", header=None, names = column_names, engine = 'python')  # importing the train dataset
test = pd.read_csv('adult_test (1).txt', sep=",\s", header=None, names = column_names, engine = 'python')   # importing the test dataset
test['income'].replace(regex=True,inplace=True,to_replace=r'\.',value=r'')

data = pd.concat([test,train])  # Concating the train and test dataset to get the actual dataset

data.reset_index(inplace = True, drop = True)  # Resetting the index

# Setting all data categorical columns to type category
for col in set(data.columns) - set(data.describe().columns):
    data[col] = data[col].astype('category')

data.info()

data.head()  #Top 5 record

data.describe()  #Statistical Description

# Calculating the missing values having ? mark
print("Missing Values")
for i,j in zip(data.columns,(data.values.astype(str) == '?').sum(axis = 0)):
    if j > 0:
        print(str(i) + ': ' + str(j) + ' records')

# User defined function to create one hot encoding of the categorical columns in dataframe
def oneHotEncode(df, df_cols):

    df_1 = df.drop(columns = df_cols, axis = 1)
    df_2 = pd.get_dummies(df[df_cols])

    return (pd.concat([df_1, df_2], axis=1, join='inner'))

# Filling the missing values of workclass attribute using Decision Tree Classifier

test_data = data[(data.workclass.values == '?')].copy()
test_label = test_data.workclass

train_data = data[(data.workclass.values != '?')].copy()
train_label = train_data.workclass

test_data.drop(columns = ['workclass'], inplace = True)
train_data.drop(columns = ['workclass'], inplace = True)

train_data = oneHotEncode(train_data, train_data.select_dtypes('category').columns)
test_data = oneHotEncode(test_data, test_data.select_dtypes('category').columns)


model = tree.DecisionTreeClassifier()
model = model.fit(train_data, train_label)
model_pred = model.predict(test_data)


data.loc[(data.workclass.values == '?'),'workclass'] = model_pred
print(data.workclass.value_counts())
print(data.workclass.unique())

# # Filling the missing values of occupation attribute using Decision Tree Classifier


test_data = data[(data.occupation.values == '?')].copy()
test_label = test_data.occupation

train_data = data[(data.occupation.values != '?')].copy()
train_label = train_data.occupation

test_data.drop(columns = ['occupation'], inplace = True)
train_data.drop(columns = ['occupation'], inplace = True)

train_data = oneHotEncode(train_data, train_data.select_dtypes('category').columns)
test_data = oneHotEncode(test_data, test_data.select_dtypes('category').columns)


model = tree.DecisionTreeClassifier()
model = model.fit(train_data, train_label)
model_pred = model.predict(test_data)


data.loc[(data.occupation.values == '?'),'occupation'] = model_pred
print(data.occupation.value_counts())
print(data.occupation.unique())

# Filling the missing values of native-country attribute using Decision Tree Classifier

test_data = data[(data['native-country'].values == '?')].copy()
test_label = test_data['native-country']

train_data = data[(data['native-country'].values != '?')].copy()
train_label = train_data['native-country']

test_data.drop(columns = ['native-country'], inplace = True)
train_data.drop(columns = ['native-country'], inplace = True)

train_data = oneHotEncode(train_data, train_data.select_dtypes('category').columns)
test_data = oneHotEncode(test_data, test_data.select_dtypes('category').columns)

model = tree.DecisionTreeClassifier()
model = model.fit(train_data, train_label)
model_pred = model.predict(test_data)


data.loc[(data['native-country'].values == '?'),'native-country'] = model_pred
print(data['native-country'].value_counts())
print(data['native-country'].unique())

# Resetting the categories

data['workclass'] = data['workclass'].cat.remove_categories('?')
data['occupation'] = data['occupation'].cat.remove_categories('?')
data['native-country'] = data['native-country'].cat.remove_categories('?')

# Correlation Plot

correlation = data.corr()
plt.figure(figsize = (7, 5))
sns.heatmap(correlation, annot = True,fmt = '.2f', cmap = 'coolwarm')
plt.title('Correlation between features')

# Pie chart for Gender status for income greater than 50K a year

filtered_data = data[(data['income'] == '>50K')]

gender_status_counts = filtered_data['gender'].value_counts()

plt.figure(figsize=(10, 6))
plt.pie(gender_status_counts, labels=gender_status_counts.index, autopct='%1.1f%%')
plt.title('Gender status for income >50K')
plt.axis('equal')

# Creating a dictionary that contain the education and it's corresponding education level

edu_level = {}
for x,y in data[['educational-num','education']].drop_duplicates().itertuples(index=False):
    edu_level[y] = x

# Education vs Income Bar Plot

education = round(pd.crosstab(data.education, data.income).div(pd.crosstab(data.education, data.income).apply(sum,1),0),2) # axis is 1 for column wise operation
education = education.reindex(sorted(edu_level, key=edu_level.get, reverse=False))

ax = education.plot(kind ='bar', title = 'Proportion distribution across education levels', figsize = (10,8))
ax.set_xlabel('Education level')
ax.set_ylabel('Proportion of population')

# Occupation vs Income Bar Plot

occupation = round(pd.crosstab(data.occupation, data.income).div(pd.crosstab(data.occupation, data.income).apply(sum,1),0),2)
occupation.sort_values(by = '>50K', inplace = True)
ax = occupation.plot(kind ='bar', title = 'Proportion distribution across Occupation levels', figsize = (10,8))
ax.set_xlabel('Occupation level')
ax.set_ylabel('Proportion of population')

# Gender vs Income Barplot

gender_workclass = round(pd.crosstab(data.workclass, [data.income, data.gender]).div(pd.crosstab(data.workclass, [data.income, data.gender]).apply(sum,1),0),2)
gender_workclass[[('>50K','Male'), ('>50K','Female')]].plot(kind = 'bar', title = 'Proportion distribution across gender for each workclass', figsize = (10,8), rot = 30)
ax.set_xlabel('Gender level')
ax.set_ylabel('Proportion of population')

# Native Country vs Income Bar Plot

native_country = round(pd.crosstab(data['native-country'], data.income).div(pd.crosstab(data['native-country'], data.income).apply(sum,1),0),2)
native_country.sort_values(by = '>50K', inplace = True)
ax = native_country.plot(kind ='bar', title = 'Proportion distribution across Native Country levels', figsize = (20,12))
ax.set_xlabel('Native country')
ax.set_ylabel('Proportion of population')

# Age vs Income Violin Plot

sns.violinplot(x='income', y='age', data=data, palette='colorblind')
plt.title('Relation of Age with Income', fontsize = 20)